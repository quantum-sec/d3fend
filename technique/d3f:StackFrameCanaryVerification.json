{"@context":{"rdfs":"http://www.w3.org/2000/01/rdf-schema#","d3f":"http://d3fend.mitre.org/ontologies/d3fend.owl#","kb-article":"d3f:kb-article","definition":"d3f:definition","kb-reference":{"@id":"d3f:kb-reference","@container":"@set"}},"@graph":[{"@id":"_:b0"},{"@id":"d3f:ApplicationHardening"},{"@id":"d3f:Harden"},{"@id":"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs"},{"@id":"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat"},{"@id":"d3f:StackFrame"},{"@id":"d3f:StackFrameCanaryVerification","@type":["d3f:ApplicationHardening","http://www.w3.org/2002/07/owl#NamedIndividual","http://www.w3.org/2002/07/owl#Class"],"d3f:d3fend-id":"D3-SFCV","definition":"Comparing a value stored in a stack frame with a known good value in order to prevent or detect a memory segment overwrite.","d3f:enables":{"@id":"d3f:Harden"},"kb-article":"## How it works\n\nThis defense must be applied at compile-time, or via a patch to the program binary.  Stack Frame Canary Verification inserts instructions at the prologue and epilogue of desired functions.  In the prologue, a canary value, typically with the same size as the register size, is stored in the system of record and on the stack.  Typically, the canary is loaded to where it has a memory address just below that of the saved instruction pointer and base pointer.  In the epilogue, the canary value stored on the stack and, is compared to the canary value in the system of record.  If the values are different, other techniques such as those in Process Eviction might be invoked, such as Process Termination to end the current process, or Executable Blacklisting to blacklist the potentially vulnerable or malfunctioning executable.\n\nStack Frame Canary Verification is commonly used to detect potential tampering of a saved register value on the stack before it has been restored.  Examples of registers with values commonly saved to the stack include the instruction pointer and the base pointer.\n\nThe canary should be stored between where the start of a buffer overrun is likely, and the data to protect, in cases where the buffer size increases it will overwrite the data to be protected.\n\nOn most processor architectures, including x86, x64, and ARM, a “push” operation to store data to the stack grows the stack towards a lower memory address.  As in these architectures, saved register values are stored to the stack at a point in time just before space is made for the local function variables, the saved register values have a higher address than that of the local function variables.  Values at increasing indexes of a buffer are written to increasing memory addresses; therefore, an overwrite in the local variable buffer could overwrite saved register values, and a stack canary between these two would be useful in detecting an overwrite.\n\nOn some other processor architectures such as the B5000, the stack grows towards increasing memory addresses, and some architectures, such as System Z and RCA1802A, stack direction can be chosen.  If the stack grows towards increasing memory addresses, while this architecture inherently provides more protection against a saved register being overwritten, other data including local function variables might be overwritten.\n\n\n## Considerations\n\nThere are several ways that the protection provided by a canary could be rendered ineffective.\n\n### Performing a malicious action before the canary is checked\n\nIf the attacker alters the memory in such a way that it performs a malicious action before the epilogue is called, then this protection will not be effective.  This includes altering the logic of the program by altering the values of local variables stored on the function stack, or by causing an exception and exploiting the exception mechanism such as the SEH (Structured Exception Handling) mechanism on Windows.\n\n### Determining the canary value\n\nDetermining the canary value is possible through reading memory either for the code used to check the canary, or from the stored canary value itself in a stack frame.\n\n### Changing the canary value\n\nA vulnerability such as a write-what-where condition that allows one to write data after the canary in the stack, would allow control of the value of the saved instruction pointer without needing to know the canary value.","kb-reference":[{"@id":"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs"},{"@id":"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat"}],"d3f:verifies":{"@id":"d3f:StackFrame"},"rdfs:label":"Stack Frame Canary Verification","rdfs:subClassOf":[{"@id":"d3f:ApplicationHardening"},{"@id":"_:b0"}]}],"_:b0":{"@id":"_:b0"},"d3f:ApplicationHardening":{"@id":"d3f:ApplicationHardening"},"d3f:Harden":{"@id":"d3f:Harden"},"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs":{"@id":"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs"},"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat":{"@id":"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat"},"d3f:StackFrame":{"@id":"d3f:StackFrame"},"d3f:StackFrameCanaryVerification":{"@id":"d3f:StackFrameCanaryVerification","@type":["d3f:ApplicationHardening","http://www.w3.org/2002/07/owl#NamedIndividual","http://www.w3.org/2002/07/owl#Class"],"d3f:d3fend-id":"D3-SFCV","definition":"Comparing a value stored in a stack frame with a known good value in order to prevent or detect a memory segment overwrite.","d3f:enables":{"@id":"d3f:Harden"},"kb-article":"## How it works\n\nThis defense must be applied at compile-time, or via a patch to the program binary.  Stack Frame Canary Verification inserts instructions at the prologue and epilogue of desired functions.  In the prologue, a canary value, typically with the same size as the register size, is stored in the system of record and on the stack.  Typically, the canary is loaded to where it has a memory address just below that of the saved instruction pointer and base pointer.  In the epilogue, the canary value stored on the stack and, is compared to the canary value in the system of record.  If the values are different, other techniques such as those in Process Eviction might be invoked, such as Process Termination to end the current process, or Executable Blacklisting to blacklist the potentially vulnerable or malfunctioning executable.\n\nStack Frame Canary Verification is commonly used to detect potential tampering of a saved register value on the stack before it has been restored.  Examples of registers with values commonly saved to the stack include the instruction pointer and the base pointer.\n\nThe canary should be stored between where the start of a buffer overrun is likely, and the data to protect, in cases where the buffer size increases it will overwrite the data to be protected.\n\nOn most processor architectures, including x86, x64, and ARM, a “push” operation to store data to the stack grows the stack towards a lower memory address.  As in these architectures, saved register values are stored to the stack at a point in time just before space is made for the local function variables, the saved register values have a higher address than that of the local function variables.  Values at increasing indexes of a buffer are written to increasing memory addresses; therefore, an overwrite in the local variable buffer could overwrite saved register values, and a stack canary between these two would be useful in detecting an overwrite.\n\nOn some other processor architectures such as the B5000, the stack grows towards increasing memory addresses, and some architectures, such as System Z and RCA1802A, stack direction can be chosen.  If the stack grows towards increasing memory addresses, while this architecture inherently provides more protection against a saved register being overwritten, other data including local function variables might be overwritten.\n\n\n## Considerations\n\nThere are several ways that the protection provided by a canary could be rendered ineffective.\n\n### Performing a malicious action before the canary is checked\n\nIf the attacker alters the memory in such a way that it performs a malicious action before the epilogue is called, then this protection will not be effective.  This includes altering the logic of the program by altering the values of local variables stored on the function stack, or by causing an exception and exploiting the exception mechanism such as the SEH (Structured Exception Handling) mechanism on Windows.\n\n### Determining the canary value\n\nDetermining the canary value is possible through reading memory either for the code used to check the canary, or from the stored canary value itself in a stack frame.\n\n### Changing the canary value\n\nA vulnerability such as a write-what-where condition that allows one to write data after the canary in the stack, would allow control of the value of the saved instruction pointer without needing to know the canary value.","kb-reference":[{"@id":"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs"},{"@id":"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat"}],"d3f:verifies":{"@id":"d3f:StackFrame"},"rdfs:label":"Stack Frame Canary Verification","rdfs:subClassOf":[{"@id":"d3f:ApplicationHardening"},{"@id":"_:b0"}]},"name":"d3f:StackFrameCanaryVerification","related_offensive_matrix":{"Privilege Escalation":[["Exploitation for Privilege Escalation",[{"otech_parent_string":{"type":"literal","value":"Privilege Escalation Technique"},"otech_parent_is_toplevel":{"datatype":"http://www.w3.org/2001/XMLSchema#boolean","type":"literal","value":"true"},"otech_string":{"type":"literal","value":"Exploitation for Privilege Escalation"},"otech_id":{"type":"literal","value":"T1068"},"offensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#PrivilegeEscalation"},"otactic_string":{"type":"literal","value":"Privilege Escalation"},"offensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"},"offensive_technique":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#T1068"},"offensive_artifact_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#may-modify"},"o_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"o_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"d_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"d_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"defensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Harden"},"defensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"}}]]],"Execution":[["Exploitation for Client Execution",[{"otech_parent_string":{"type":"literal","value":"Execution Technique"},"otech_parent_is_toplevel":{"datatype":"http://www.w3.org/2001/XMLSchema#boolean","type":"literal","value":"true"},"otech_string":{"type":"literal","value":"Exploitation for Client Execution"},"otech_id":{"type":"literal","value":"T1203"},"offensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Execution"},"otactic_string":{"type":"literal","value":"Execution"},"offensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"},"offensive_technique":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#T1203"},"offensive_artifact_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#modifies"},"o_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"o_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"d_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"d_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"defensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Harden"},"defensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"}}]]],"Lateral Movement":[["Exploitation of Remote Services",[{"otech_parent_string":{"type":"literal","value":"Lateral Movement Technique"},"otech_parent_is_toplevel":{"datatype":"http://www.w3.org/2001/XMLSchema#boolean","type":"literal","value":"true"},"otech_string":{"type":"literal","value":"Exploitation of Remote Services"},"otech_id":{"type":"literal","value":"T1210"},"offensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#LateralMovement"},"otactic_string":{"type":"literal","value":"Lateral Movement"},"offensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"},"offensive_technique":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#T1210"},"offensive_artifact_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#may-modify"},"o_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"o_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"d_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"d_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"defensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Harden"},"defensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"}}]]],"Defense Evasion":[["Exploitation for Defense Evasion",[{"otech_parent_string":{"type":"literal","value":"Defense Evasion Technique"},"otech_parent_is_toplevel":{"datatype":"http://www.w3.org/2001/XMLSchema#boolean","type":"literal","value":"true"},"otech_string":{"type":"literal","value":"Exploitation for Defense Evasion"},"otech_id":{"type":"literal","value":"T1211"},"offensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#DefenseEvasion"},"otactic_string":{"type":"literal","value":"Defense Evasion"},"offensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"},"offensive_technique":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#T1211"},"offensive_artifact_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#may-modify"},"o_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"o_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"d_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"d_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"defensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Harden"},"defensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"}}]]],"Credential Access":[["Exploitation for Credential Access",[{"otech_parent_string":{"type":"literal","value":"Credential Access Technique"},"otech_parent_is_toplevel":{"datatype":"http://www.w3.org/2001/XMLSchema#boolean","type":"literal","value":"true"},"otech_string":{"type":"literal","value":"Exploitation for Credential Access"},"otech_id":{"type":"literal","value":"T1212"},"offensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#CredentialAccess"},"otactic_string":{"type":"literal","value":"Credential Access"},"offensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"},"offensive_technique":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#T1212"},"offensive_artifact_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#may-modify"},"o_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"o_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"d_digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"d_digital_artifact_string":{"type":"literal","value":"Stack Frame"},"defensive_tactic":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#Harden"},"defensive_verb":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#enables"}}]]]},"digital_artifacts":{"head":{"vars":["relationship","relationship_label","relationship_comment","digital_artifact","digital_artifact_label","digital_artifact_comment"]},"results":{"bindings":[{"relationship":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#verifies"},"relationship_label":{"type":"literal","value":"verifies"},"relationship_comment":{"type":"literal","value":"x verifies y: A technique x confirms the truth of a digital artifact y."},"digital_artifact":{"type":"uri","value":"http://d3fend.mitre.org/ontologies/d3fend.owl#StackFrame"},"digital_artifact_label":{"type":"literal","value":"Stack Frame"},"digital_artifact_comment":{"type":"literal","value":"A machine-dependent and application-binary-dependent (ABI-dependent) data structure containing subroutine state information including the arguments passed into the routine, the return address back to the routine's caller, and space for local variables of the routine."}}]}},"references":{"@context":{"rdfs":"http://www.w3.org/2000/01/rdf-schema#","d3f":"http://d3fend.mitre.org/ontologies/d3fend.owl#"},"@graph":[{"@id":"d3f:Reference_/GS(BufferSecurityCheck)_MicrosoftDocs","@type":["d3f:UserManualReference","http://www.w3.org/2002/07/owl#NamedIndividual"],"d3f:has-link":{"@type":"http://www.w3.org/2001/XMLSchema#anyURI","@value":"https://docs.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=vs-2019"},"d3f:kb-abstract":"","d3f:kb-author":"","d3f:kb-is-example-of":{"@id":"d3f:StackFrameCanaryVerification"},"d3f:kb-mitre-analysis":"","d3f:kb-organization":"Microsoft Docs","d3f:kb-reference-title":"/GS (Buffer Security Check)","d3f:reference-type-label":"User Manual","rdfs:label":"Reference - /GS (Buffer Security Check) - Microsoft Docs"},{"@id":"d3f:Reference_SecurityTechnologies:StackSmashingProtection(StackGuard)_RedHat","@type":["d3f:InternetArticleReference","http://www.w3.org/2002/07/owl#NamedIndividual"],"d3f:has-link":{"@type":"http://www.w3.org/2001/XMLSchema#anyURI","@value":"https://access.redhat.com/blogs/766093/posts/3548631"},"d3f:kb-abstract":"In our previous blog, we saw how arbitrary code execution resulting from stack-buffer overflows can be partly mitigated by marking segments of memory as non-executable, a technology known as Execshield. However stack-buffer overflow exploits can still effectively overwrite the function return address, which leads to several interesting exploitation techniques like ret2libc, ret2gets, and ret2plt. With all of these methods, the function return address is overwritten and attacker controlled code is executed when the program control transfers to overwritten address on the stack.","d3f:kb-author":"Huzaifa Sidhpurwala","d3f:kb-is-example-of":{"@id":"d3f:StackFrameCanaryVerification"},"d3f:kb-mitre-analysis":"","d3f:kb-organization":"Red Hat","d3f:kb-reference-title":"Security Technologies: Stack Smashing Protection (StackGuard)","d3f:reference-type-label":"Internet Article","rdfs:label":"Reference - Security Technologies: Stack Smashing Protection (StackGuard) - Red Hat"}]},"references_meta":{"User Manual":1,"Internet Article":1}}